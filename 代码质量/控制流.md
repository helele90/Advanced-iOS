# 表达式
## 表达式不要太长
表达式越长越难理解。
```swift
    let a = a == 1 && b == 2 && c > 3 && c < 4
```
### 拆分

# 控制流

## 减少嵌套
嵌套层数越多越难理解。需要关注每一层嵌套的上下文和作用域范围。减少嵌套可以使代码变的更加线性更容易理解。
### 函数提前返回
优先检查不符合的条件，提前返回
###### 推荐
```swift
func method(a: String?, b: Bool) {
    if a == nil {
        return
    }

    guard b else {
        return
    }
    // do
}
```
###### 不推荐
```swift
func method(a: String?, b: Bool) {
    if a != nil {
        if !b {
            // do
        }
    }
}
```

### 分解条件表达式
使用变量来拆分一部分表达式，提高可读性。
###### 推荐
```swift
let date = Date()
let validDate = date.isToday() && date.isMonday() && date.isAfterNoon
if (validDate && needsRefresh) {

}
```
###### 不推荐
```swift
let date = Date()
if (date.isToday() && date.isMonday() && date.isAfterNoon && needsRefresh) {
    
}
```

### 合并条件表达式
###### 推荐
```swift
func method() -> Bool {
    return a && b && c
}
```
###### 不推荐
```swift
func method() -> Bool {
    if (a && b && c) {
        return true
    }

    return false
}
```

### 减少循环嵌套
###### 推荐使用`coninue`减少嵌套
```swift
for index in 0..<10 {
    if index == 4 {
        continue
    }
    // do
}
```
###### 不推荐
```swift
for index in 0..<10 {
    if index == 4 {
        // do
    }
}
```

# 变量
## 减少变量
变量越多越容易出现bug。
### 使用filter/map/reduce
###### 推荐
```swift
var nums = [1, 2, 3]
var result = nums.filter { $0 < 3 }.map { String($0) }
// result = ["1", "2"]
```
- 更少的局部变量
- 代码可读性更强
###### 不推荐
```swift
var nums = [1, 2, 3]
var result = []
for num in nums {
    if num < 3 {
        result.append(String(num))
    }
}
// result = ["1", "2"]
```

### 保持变量作用域最小
- 变量应该在离使用最近的地方，当阅读代码时也更容易理解
- 也可以减少一些不必要的计算
```swift
    func method() {
        let num = 1
        let name = "name"
        // 多行代码
        if num == 2 {
            print(name)
        }
    }
```
- num/name变量创建过早
- name不一定会使用到

### 使用计算属性
使用场景：
- 某些值可以通过其他值计算出来
- 计算消耗相对比较低
> 提示：还可以带来其他好处，避免数据修改时忘记同步其他变量。
```swift
struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
```

### 优先使用不可变变量
使用常量可以限制对数据的修改，数据的修改更容易产生bug。
> 提示：数据修改是产生bug最主要的原因。
> 提示：还有一点也非常重要。大家有时候可能会觉得，自己实现这块代码，自己可以保证不会去修改这些值。可是为什么我们不直接在编译层面限制这些行为呢，当修改常量时，编译器会直接提示错误。
##### 初始化注入
###### 推荐
```swift
class Order {
    let orderId: Int
    init(orderId: Int) {
        self.num = num
    }
}
let order = Order(orderId: 1)
```
###### 不推荐
```swift
class Object {
    var orderId: Int
}
let object = Object()
object.orderId = 1
```
> 提示：虽然功能一样，但是没办法限制外部修改orderId。


# 作用域
##### 最小作用域